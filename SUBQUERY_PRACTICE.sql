/* SUBQUERY IS A SQL QUERY WHICH IS PLACEDD INSIDE ANOTHER QUERY. */

CREATE DATABASE PRACTICE;
USE  PRACTICE;
DROP TABLE NT_SUBQUERY;
DROP TABLE NT_DEPARTMENT;

CREATE TABLE NT_SUBQUERY
(
EMPLOYEE_ID INT PRIMARY KEY,
EMPLOYEE_NAME VARCHAR(30),
DEPARTMENT_NAME VARCHAR(30),
SALARY INT
);

INSERT INTO NT_SUBQUERY VALUES
(101, 'NISHA', 'DATA ANALYST', 50000),
(102, 'SANTHOSH', 'DATA ANALYST', 60000),
(103, 'PUTUL', 'DATA SCIENTIST', 70000),
(104, 'RITESH', 'DATA SCIENTIST', 80000),
(105, 'NIKITA', 'HR', 50000),
(106, 'PRINCR', 'HR', 60000),
(107, 'VARUN', 'BIG DATA', 70000),
(108, 'DILIP', 'BIG DATA', 40000),
(109, 'MANOJ', 'DATA SCIENTIST', 50000),
(110, 'SIMRAN', 'DATA ENGINEER', 30000),
(111, 'RAJ', 'DATA ANALYST', 40000),
(112, 'PUJA', 'IT', 50000),
(113, 'REKHA', 'IT', 60000),
(114, 'HEMA', 'FINANCE', 70000),
(115, 'JAYA', 'FINANCE', 30000),
(116, 'SUSHMA', 'ADMIN', 30000),
(117, 'MIRA', 'ADMIN', 20000),
(118, 'NAINA', 'INSURANCE', 40000),
(119, 'SHUBHAM', 'INSURANCE', 30000),
(120, 'RAHUL', 'DATA SCIENTIST', 50000),
(121, 'ANUJ', 'DATA ANALYST', 60000),
(122, 'MANISH', 'DATA ENGINEER', 70000),
(123, 'RISHABH', 'DATA ANALYST', 60000),
(124, 'SHIVAM', 'BID DATA', 50000);

CREATE TABLE NT_DEPARTMENT
(
DEPARTMENT_ID int PRIMARY KEY,
DEPARTMENT_NAME VARCHAR (50),
LOCATION VARCHAR (30));

INSERT INTO NT_DEPARTMENT VALUES
(1, 'DATA ANALYST', 'BANGALORE'),
(2, 'DATA SCIENTIST', 'BANGALORE'),
(3, 'HR', 'HYDERABAD'),
(4, 'BIG DATA', 'HYDERABAD'),
(5, 'DATA ENGINEER', 'PUNE'),
(6, 'IT', 'PUNE'),
(7, 'FINANCE', 'NAGPUR'),
(8, 'ADMIN', 'NAGPUR'),
(9, 'INSURANCE', 'INDORE'),
(10, 'AGRICULTURE', 'NOIDA'),
(11, 'BANKING', 'JAIPUR');



SELECT DISTINCT * FROM NT_SUBQUERY;
SELECT DISTINCT DEPARTMENT_NAME FROM NT_SUBQUERY 

-- FIND THE EMPLOYEES WHOSE SALARY IS MORE THAN THE AVERAGE SALARY EARNED BY ALL THE EMPLOYEES --
-- 1. FIND THE AVG SALARY OF ALL THE EMPLOYEE --
-- 2. THEN FIND THE SALARY EMPLOYEES WHOSE SALARY ARE MORE THAN THE AVERAGE SALARY) --
SELECT AVG(SALARY) FROM NT_SUBQUERY; -- 50833.3333 --

SELECT * 
FROM NT_SUBQUERY
WHERE SALARY > 50833;  -- THIS IS NOT A DYNAIC QUERY, BECAUSE THE AVERAGE SALARY IS HARDCODED-- HENCE USE SUBQUERY

 -- USING SUBQUERY --
 
 SELECT *
 FROM NT_SUBQUERY
 WHERE SALARY > (SELECT AVG(SALARY) FROM NT_SUBQUERY); -- THIS IS A SCALAR SUBQUERY COZ THE INEER QUERY RETURNS JUST 1 ROW AND 1 COLUMN --
 
 /* THERE ARE THREE TYPES OF SUBQUERY
 1. SCALAR SUBQUERY
 2. MULTIPLE ROW SUBQUERY
 3. CORRELATED SUBQUERY
 */
 -- SCALAR SUBQUER -- IT IS THE TYPE OF SUBQUERY THAT WILL ALWAYS RETURN JUST ONE ROW AND ONE COLUMN --
 -- THERE IS ANOTHER WAY OF WRITING THE ABOVE QUERY --
 -- INSTEAD OF WRITING SUBQUERY IN WHERE CLAUSE, WE WILL WRITE IT IN THE FROM CLAUSE --
 
 SELECT *
 FROM NT_SUBQUERY AS SQ
 JOIN (SELECT AVG(SALARY) AS SAL FROM NT_SUBQUERY) AS AVG_SAL
 ON SQ.SALARY > AVG_SAL.SAL;
 
 -- MULTIPLE ROW SUBQUERY -- WHEN THE SUBQUERY WILL RETURN MULTIPLE ROWS-- 
 -- THERE ARE TWO TYPES OF MULTIPLE ROW SUBQUERY --
 -- 1. WHEN THE SUBQUERY WILL RETURN MULTIPLE ROWS AND COLUMNS--
 -- 2. WHEN THE SUBQUERY WILL RETURN ONLY 1 COLUMN AND MULTIPLE ROWS --
 
 -- FIND THE EMPLOYEES WHO EARN THE HIGHEST SALARY IN EACH DEPARTMENT --
 SELECT * FROM
  (SELECT *, ROW_NUMBER() OVER(PARTITION BY DEPARTMENT_NAME ORDER BY SALARY DESC) AS ROW_NUM 
  FROM NT_SUBQUERY) AS SQ
  WHERE ROW_NUM = 1  -- THIS IS ANOTHER WAY OF WRITING --
  
  SELECT EMPLOYEE_NAME, DEPARTMENT_NAME, MAX(SALARY)
  FROM NT_SUBQUERY
  GROUP BY DEPARTMENT_NAME
  ORDER BY SALARY DESC; -- THIS IS NORMAL WAY --
  
  SELECT * 
  FROM NT_SUBQUERY
  WHERE (DEPARTMENT_NAME, SALARY) IN (SELECT DEPARTMENT_NAME, MAX(SALARY) FROM NT_SUBQUERY
  GROUP BY DEPARTMENT_NAME) ;  -- THIS IS CALLED MULTIPLE ROW SUBQUERY) --
  
  -- SINGLE COLUMN MULTIPLE ROW SUBQUERY --
  -- FIND DEPARTMENT WHO DONOT HAVE ANY EMPLOYEE --
SELECT DISTINCT DEPARTMENT_NAME FROM NT_SUBQUERY;
SELECT DISTINCT DEPARTMENT_NAME FROM NT_DEPARTMENT;

SELECT *
FROM NT_DEPARTMENT
WHERE DEPARTMENT_NAME NOT IN (SELECT DISTINCT DEPARTMENT_NAME FROM NT_SUBQUERY); -- THIS IS USING SUBQUERY --

SELECT SQ.EMPLOYEE_NAME, D.DEPARTMENT_NAME
FROM NT_DEPARTMENT D
LEFT OUTER JOIN  NT_SUBQUERY SQ ON D.DEPARTMENT_NAME = SQ.DEPARTMENT_NAME -- SAME OUTPUT USING JOIN CONCEPT --

-- CORRELATED SUBQUERY --
-- IT IS THE SUBQUERY WHICH IS RELATED TO THE OUTER QUERY --
-- THE PROCESSING OF THE SUBQUERY DEPENDS ON THE VALUES THAT ARE RETURNED FROM THE OUTER QUERY --
-- FIND THE EMPLOYEES IN EACH DEPARTMENT WHO EARN MORE THAN THE AVERAGE SALARY IN THAT DEPARTMENT --

SELECT DEPARTMENT_NAME, AVG(SALARY) 
FROM NT_SUBQUERY
GROUP BY DEPARTMENT_NAME -- THIS IS BY NORMAL METHOD --

SELECT * 
FROM NT_SUBQUERY AS E1
WHERE SALARY > (SELECT AVG(SALARY)
			   FROM NT_SUBQUERY E2
               WHERE E2.DEPARTMENT_NAME = E1.DEPARTMENT_NAME); -- CORRELATED SUBQUERY --
               
-- THE DISADVANTAGE OF CORRELATED SUBQUERY IS THAT IT WILL PROCESS THE OUTER QUREY MULTIPLE TIME --

-- NESTED SUBQUERY -- 
-- SUBQUERY INSIDE A SUBSQUERY INSIDE A SUBQUERY --
CREATE TABLE NT_SALES5
(
STORE_ID int,
STORE_NAME VARCHAR (50),
PRODUCT_NAME VARCHAR (50),
QUANTITY INT,
PRICE INT);

INSERT INTO NT_SALES5 VALUES
(1, 'APPLE STOERE1', 'IPHONE13 PRO', 1, 100),
(1, 'APPLE STOERE1', 'IPHONE14 PRO', 2, 200),
(1, 'APPLE STOERE1', 'MACBOOK', 3, 200),
(2, 'APPLE STOERE2', 'AIRPOD', 4, 500),
(2, 'APPLE STOERE2', 'AIRPOD PRO', 3, 1000),
(3, 'APPLE STOERE3', 'IPHONE12 PRO', 2, 1500),
(3, 'APPLE STOERE3', 'IPHONE12', 2, 2500),
(4, 'APPLE STOERE4', 'SMARTWATCH', 3, 1500),
(4, 'APPLE STOERE4', 'MACKBOOK13 PRO', 1, 300),
(5, 'APPLE STOERE5', 'MACKBOOK PRO', 1, 200),
(5, 'APPLE STOERE5', 'IPHONE15 PRO', 1, 250);

-- FIND STORES WHOSE SALES ARE BETTER THAN THE AVERAGE SALES ACROSS ALL STORES --
-- 1. FIND TOTAL SALES FOR EACH STORE --
-- 2. FIND AVERAGE SALES FOR ALL STORES --
-- 3. COMPARE 1 AND 2


SELECT * FROM NT_SALES5
SELECT AVG (QUANTITY * PRICE) FROM NT_SALES5;

SELECT *
FROM (SELECT STORE_NAME, SUM(QUANTITY * PRICE) AS TOTAL_SALES
       FROM NT_SALES5
       GROUP BY STORE_NAME) AS Y
JOIN (SELECT AVG(TOTAL_SALES) AS SALES
FROM (SELECT STORE_NAME, SUM(QUANTITY * PRICE) AS TOTAL_SALES
       FROM NT_SALES5
       GROUP BY STORE_NAME) AS X) AVERAGE_SALES
ON Y.TOTAL_SALES > AVERAGE_SALES.SALES; -- THIS IS NOT THE BEST WAY OF WRITING THE SUBQUERY, COZ THE SAME SUBQUERY IS REPEATED MULTIPLE TIMES, HENCE WE CAN USE WITH CLAUSE --

WITH SALES AS (SELECT STORE_NAME, SUM(QUANTITY * PRICE) AS TOTAL_SALES
       FROM NT_SALES5
       GROUP BY STORE_NAME)
SELECT *
FROM SALES
JOIN (SELECT AVG(TOTAL_SALES) AS SALES
FROM SALES X) AVERAGE_SALES
ON SALES.TOTAL_SALES > AVERAGE_SALES.SALES;  -- THIS IS USING WITH CLAUSE --

-- THE SUBQUERIES CAN BE USED ON --
-- 1. SELECT CLAUSE --
-- 2. FROM CLAUSE --
-- 3. WHERE CLAUSE --
-- 4. HAVING CLAUSE --

-- ON SELECT -- USUALLY THIS SHOULD BE AVOIDED --
-- FETCH ALL EMPLOYEES DETAILS AND ADD REMARKS TO THOSE EMPLOYEES  WHO EARN MORE THAN THE AVERAGE PAY --

SELECT *, (CASE WHEN SALARY >(SELECT AVG(SALARY) FROM NT_SUBQUERY)
                THEN 'HIGHER THAN AVERAGE'
                ELSE 'NULL'
                END) AS REMARKS
FROM NT_SUBQUERY; -- THIS IS NOT THE BEST METHOD OF WRITING THE QUERY COZ IT INCREASES THE COMPUTATIONAL TIME --

-- AVOID SUBQUERY IN THE SELECT CLAUSE, INSTEAD YOU CAN USE JOIN CONDITION --

-- FROM CLAUSE --

SELECT *, (CASE WHEN SALARY >AVERAGE_SALARY.SAL
                THEN 'HIGHER THAN AVERAGE'
                ELSE 'NULL'
                END) AS REMARKS
FROM NT_SUBQUERY
CROSS JOIN (SELECT AVG(SALARY) AS SAL FROM NT_SUBQUERY) AS AVERAGE_SALARY;


-- HAVING CLAUSE --
-- FIND THE STORES WHO HAVE SOLD MORE UNITS THAN THE AVERAGE UNITS SOLD BY ALL THE STORE --
SELECT STORE_NAME, SUM(QUANTITY)
from NT_SALES5
GROUP BY STORE_NAME
HAVING SUM(QUANTITY) > (SELECT AVG(QUANTITY) FROM NT_SALES5);

-- SQL COMMANDS WHICH ALLOW SUBQUERY --
-- 1. INSERT --
-- 2. UPDATE --
-- 3. DELETE --
-- 4. SQL QUERY -- THIS IS ALREADY DONE -- THE ABOVE EXAMPLES WERE ON SQLL QUERIES --

-- INSERT --
-- INSERT DATA TO EMPLOYEE HISTORY TABLE. MAKE SURE NOT TO INSERT DUPLICATE RECORDS --

CREATE TABLE NT_EMPLOYEE_HISTORY 
(EMPLOYEE_ID INT PRIMARY KEY,
EMPLOYEE_NAME VARCHAR(30),
DEPARTMENT_NAME VARCHAR(30),
SALARY INT,
LOCATION VARCHAR (30)) -- THIS TABLE IS SIMILAR TO THE THE NT_SUBQUERY AND NT_DEPARTMENT, THUS NO NEED TO INSERT THE VALUES, JUST USE SUBQUERY IN THE INSERT CLAUSE USING JOIN --

INSERT INTO NT_EMPLOYEE_HISTORY
SELECT SQ.EMPLOYEE_ID, SQ.EMPLOYEE_NAME, SQ.DEPARTMENT_NAME, SQ.SALARY, D.LOCATION
FROM NT_SUBQUERY SQ
JOIN NT_DEPARTMENT D ON  SQ.DEPARTMENT_NAME = D.DEPARTMENT_NAME
WHERE NOT EXISTS (SELECT 1 
                   FROM NT_EMPLOYEE_HISTORY AS EH
                   WHERE EH.EMPLOYEE_ID = SQ.EMPLOYEE_ID);

SELECT * FROM NT_EMPLOYEE_HISTORY

-- UPDATE COMMAND --
-- GIVE 10% INCREMENT TO ALL EMPOYEES IN BANGALORE LOCATION BASED ON THE MAXIMUM SALARY EARNED BY AN EMPLOYEE IN EACH DEPARTMENT. --
-- ONLY CONSIDER EMPLOYEES IN EMPLOYEE HISTORY TABLE --

UPDATE NT_SUBQUERY AS SQ
SET SALARY = (SELECT MAX(SALARY) + (MAX(SALARY) *0.1)
              FROM NT_EMPLOYEE_HISTORY AS EH
              WHERE EH.DEPARTMENT_NAME = SQ.DEPARTMENT_NAME)
WHERE SQ.DEPARTMENT_NAME IN (SELECT DEPARTMENT_NAME FROM NT_DEPARTMENT WHERE LOCATION = 'BANGALORE')
AND SQ.EMPLOYEE_ID IN (SELECT EMPLOYEE_ID FROM NT_EMPLOYEE_HISTORY);

-- DELETE CLAUSE --
-- DELETE ALL THE DEPARTMENTS WHO DO NOT HAVE ANY EMPLOYEES --

DELETE FROM NT_DEPARTMENT
WHERE DEPARTMENT_NAME IN (SELECT DEPARTMENT_NAME
                          FROM NT_DEPARTMENT AS D
						  WHERE NOT EXISTS (SELECT 1 
                          FROM NT_SUBQUERY SQ 
                          WHERE SQ.DEPARTMENT_NAME = D.DEPARTMENT_NAME)
                          );